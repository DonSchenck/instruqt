slug: developing-with-quarkus-getting-started
id: riixlttwv5ye
type: track
title: Getting Started with Quarkus
description: |-
  In this scenario, you will get an introduction to [Quarkus](https://quarkus.io).

  ## What is Quarkus?

  ![Logo](https://katacoda.com/openshift/assets/middleware/quarkus/logo.png)

  ### Supersonic, Subatomic Java

  For years, the client-server architecture has been the de-facto standard to build applications. But a major shift happened. The _one model rules them all_ age is over. A new range of applications and architecture styles has emerged and impacts how code is written and how applications are deployed and executed. HTTP microservices, reactive applications, message-driven microservices and serverless are now central players in modern systems.

  Quarkus has been designed with this new world in mind, and provides first-class support for these different paradigms. Quarkus development model morphs to adapt itself to the type of application you are developing.

  Quarkus is a Kubernetes Native Java stack tailored for GraalVM & OpenJDK HotSpot, crafted from the best of breed Java libraries and standards. Amazingly fast boot time, incredibly low RSS memory (not just heap size!) offering near instant scale up and high density memory utilization in container orchestration platforms like Kubernetes. Quarkus uses a technique called compile time boot. [Learn more](https://quarkus.io/vision/container-first).

  ### Unifies Imperative and Reactive

  Application requirements have changed drastically over the last few years. For any application to succeed in the era of cloud computing, big data or IoT, going reactive is increasingly becoming the architecture style to follow.

  Quarkus combines both the familiar imperative code and the non-blocking reactive style when developing applications.

  ### Functions as a Service and Serverless

  Thanks to their stellar startup time and low memory usage, you can implement functions using Quarkus to be used in serverless environments like AWS Lambda. You can use any of the Quarkus features in your function and benefit from the fast startup and low memory utilization. With Quarkus, you can embrace this new world without having to change your programming language.

  ### Developer Joy
  Quarkus provides a cohesive platform for optimized _developer joy_:

  * Unified configuration
  * Zero config, live reload in the blink of an eye
  * Streamlined code for the 80% common usages, flexible for the 20%
  * No hassle native executable generation

  ### Other possibilities

  Learn more at [quarkus.io](https://quarkus.io), or just drive on and get hands-on!
icon: https://logodix.com/logo/1910931.png
level: beginner
tags:
- openshift
owner: openshift
developers:
- nvinto@redhat.com
- rjarvine@redhat.com
- dahmed@redhat.com
private: false
published: true
challenges:
- slug: 01-create-project
  id: dowq7nqofdug
  type: challenge
  title: Step 1
  notes:
  - type: text
    contents: |-
      In this scenario, you will get an introduction to [Quarkus](https://quarkus.io).

      ## What is Quarkus?

      ![Logo](https://katacoda.com/openshift/assets/middleware/quarkus/logo.png)

      ### Supersonic, Subatomic Java

      For years, the client-server architecture has been the de-facto standard to build applications. But a major shift happened. The _one model rules them all_ age is over. A new range of applications and architecture styles has emerged and impacts how code is written and how applications are deployed and executed. HTTP microservices, reactive applications, message-driven microservices and serverless are now central players in modern systems.

      Quarkus has been designed with this new world in mind, and provides first-class support for these different paradigms. Quarkus development model morphs to adapt itself to the type of application you are developing.

      Quarkus is a Kubernetes Native Java stack tailored for GraalVM & OpenJDK HotSpot, crafted from the best of breed Java libraries and standards. Amazingly fast boot time, incredibly low RSS memory (not just heap size!) offering near instant scale up and high density memory utilization in container orchestration platforms like Kubernetes. Quarkus uses a technique called compile time boot. [Learn more](https://quarkus.io/vision/container-first).

      ### Unifies Imperative and Reactive

      Application requirements have changed drastically over the last few years. For any application to succeed in the era of cloud computing, big data or IoT, going reactive is increasingly becoming the architecture style to follow.

      Quarkus combines both the familiar imperative code and the non-blocking reactive style when developing applications.

      ### Functions as a Service and Serverless

      Thanks to their stellar startup time and low memory usage, you can implement functions using Quarkus to be used in serverless environments like AWS Lambda. You can use any of the Quarkus features in your function and benefit from the fast startup and low memory utilization. With Quarkus, you can embrace this new world without having to change your programming language.

      ### Developer Joy
      Quarkus provides a cohesive platform for optimized _developer joy_:

      * Unified configuration
      * Zero config, live reload in the blink of an eye
      * Streamlined code for the 80% common usages, flexible for the 20%
      * No hassle native executable generation

      ### Other possibilities

      Learn more at [quarkus.io](https://quarkus.io), or just drive on and get hands-on!
  assignment: |
    In this step, you will create a straightforward application serving a `hello` endpoint. To demonstrate dependency injection this endpoint uses a `greeting` bean.

    ![Architecture](https://katacoda.com/openshift/assets/middleware/quarkus/arch.png)

    # Wait for prerequisite downloads

    A suitable Java runtime is being installed and should take less than a minute. Once it's done, continue below!

    # Create basic project

    The easiest way to create a new Quarkus project is to click to run the following command:

    `mvn io.quarkus:quarkus-maven-plugin:2.0.0.Final:create \
        -DprojectGroupId=org.acme \
        -DprojectArtifactId=getting-started \
        -DclassName="org.acme.quickstart.GreetingResource" \
        -Dpath="/hello"`{{execute}}

    This will use the Quarkus Maven Plugin and generate a basic Maven project for you in the `getting-started` subdirectory, generating:

    * The Maven structure
    * An `org.acme.quickstart.GreetingResource` resource exposed on `/hello`
    * An associated unit test
    * A landing page that is accessible on `http://localhost:8080` after starting the application
    * Example `Dockerfile`s for a variety of build targets (native, jvm, etc)
    * The application configuration file

    Once generated, look at the `getting-started/pom.xml`. You will find the import of the Quarkus BOM, allowing to omit the version on the different Quarkus dependencies. In addition, you can see the `quarkus-maven-plugin` responsible of the packaging of the application and also providing the development mode.

    ```xml
      <dependencyManagement>
        <dependencies>
          <dependency>
            <groupId>${quarkus.platform.group-id}</groupId>
            <artifactId>${quarkus.platform.artifact-id}</artifactId>
            <version>${quarkus.platform.version}</version>
            <type>pom</type>
            <scope>import</scope>
          </dependency>
        </dependencies>
      </dependencyManagement>
    ```

    If we focus on the dependencies section, you can see we are using [Quarkus extensions](https://quarkus.io/extensions/) allowing the development and testing of REST applications:
    ```xml
      <dependencies>
        <dependency>
          <groupId>io.quarkus</groupId>
          <artifactId>quarkus-arc</artifactId>
        </dependency>
        <dependency>
          <groupId>io.quarkus</groupId>
          <artifactId>quarkus-resteasy</artifactId>
        </dependency>
        <dependency>
          <groupId>io.quarkus</groupId>
          <artifactId>quarkus-junit5</artifactId>
          <scope>test</scope>
        </dependency>
        <dependency>
          <groupId>io.rest-assured</groupId>
          <artifactId>rest-assured</artifactId>
          <scope>test</scope>
        </dependency>
      </dependencies>
    ```

    During the project creation, the `getting-started/src/main/java/org/acme/quickstart/GreetingResource.java` file has been created with the following endpoint:

    ```java
    @Path("/hello")
    public class GreetingResource {

        @GET
        @Produces(MediaType.TEXT_PLAIN)
        public String hello() {
            return "Hello RESTEasy";
        }
    }
    ```
    It’s a very simple REST endpoint, returning "hello" to requests on `/hello`.

    > Compared to vanilla JAX-RS, with Quarkus there is no need to create an `Application` class. It’s supported but not required. In addition, only one instance of the resource is created and not one per request. You can configure this using the different `*Scoped` annotations (`ApplicationScoped`, `RequestScoped`, etc).

    # Running the Application

    First, change to the directory in which the project was created:

    ```
    cd /root/projects/quarkus/getting-started
    ```

    Now we are ready to run our application. Click here to run:

    ```
    mvn quarkus:dev -Dquarkus.http.host=0.0.0.0
    ```

    You should see:

    ```console
    __  ____  __  _____   ___  __ ____  ______
     --/ __ \/ / / / _ | / _ \/ //_/ / / / __/
     -/ /_/ / /_/ / __ |/ , _/ ,< / /_/ /\ \
    --\___\_\____/_/ |_/_/|_/_/|_|\____/___/
    INFO  [io.quarkus] (Quarkus Main Thread) getting-started 1.0.0-SNAPSHOT on JVM (powered by Quarkus x.x.x.Final) started in 1.194s. Listening on: http://0.0.0.0:8080
    INFO  [io.quarkus] (Quarkus Main Thread) Profile dev activated. Live Coding activated.
    INFO  [io.quarkus] (Quarkus Main Thread) Installed features: [cdi, resteasy]
    --
    Tests paused, press [r] to resume, [h] for more options>
    ```

    Note the amazingly fast startup time! Once started, you can request the provided endpoint in the browser [using this link](https://[[CLIENT_SUBDOMAIN]]-8080-[[KATACODA_HOST]].environments.katacoda.com/hello).

    You should see:

    ```console
    Hello RESTEasy
    ```
    It's working!

    Now, let's exercise the **live reload** capabilities of Quarkus. Click here to open the endpoint:  `getting-started/src/main/java/org/acme/quickstart/GreetingResource.java`. Change `return "Hello RESTEasy";` to `return "Hola RESTEasy";` on line 14 in the editor. Don't save. Don't recompile or restart anything. Just try to reload the brower (or [click here](https://[[CLIENT_SUBDOMAIN]]-8080-[[KATACODA_HOST]].environments.katacoda.com/hello) again.)

    You should see the updated `hola` message.

    Wow, how cool is that? Supersonic Subatomic live reload! Go ahead and change it a few more times and access the endpoint again. And we're just getting started.

    > `quarkus:dev` runs Quarkus in development mode. This enables live reload with background compilation, which means that when you modify your Java files your resource files and refresh your browser these changes will automatically take effect.
    > This will also listen for a debugger on port `5005`. If your want to wait for the debugger to attach before running you can pass `-Ddebug` on the command line. If you don’t want the debugger at all you can use `-Ddebug=false`.

    # The Dev UI

    When running in Developer mode, Quarkus apps expose a useful UI for inspecting and making on-the-fly changes to the app (much like live coding mode). It allows you to quickly visualize all the extensions currently loaded, see and edit their configuration values, see their status and go directly to their documentation.

    To access the Dev UI for your running app, [click this link](https://[[CLIENT_SUBDOMAIN]]-8080-[[KATACODA_HOST]].environments.katacoda.com/q/dev) which should open up the Dev UI in a new browser tab.

    ![Dev UI](https://katacoda.com/openshift/assets/middleware/quarkus/dev-ui-overview.png)

    For example, click on the `Config Editor` link within the `Configuration` tile to see and make updates to configuration. This is super useful for developers to confirm code and configuration changes, or experiment with various settings.

    > **NOTE** The Dev UI is only enabled when in _developer_ mode. It is not deployed when in production mode, as it's designed for developers to use during development. For more detail on what you can do, check out the [Dev UI Guide](https://quarkus.io/guides/dev-ui).

    # Continuous Testing

    When in developer mode (via `mvn quarkus:dev`), Quarkus can automatically and continuously run your unit tests. You may have noticed in the console `Tests paused, press [r] to resume, [h] for more options>`. This is an indication that you can enter continuous test mode. Type `r` to turn continuous testing mode on in the console.

    Earlier, you changed `Hello` to `Hola` which broke the default unit test, and you can now see this in the console:

    ```
    Response body doesn't match expectation.
    Expected: is "Hello RESTEasy"
      Actual: Hola RESTEasy
    ```

    Let's fix the test. Change `Hola RESTEasy` back to `Hello RESTEasy` in the editor. As soon as you fix it, Quarkus automatically re-runs the test and you should now have passing tests:

    ```
    All 1 tests are passing (0 skipped), 1 tests were run in 389ms. Tests completed at 12:25:40 due to changes to GreetingResource.class.
    ```

    Quarkus analyses your unit tests and only re-runs the tests that are affected by code changes. It's one of many developer productivity features of Quarkus, providing immediate feedback to developers as they type. We'll leave the tests running continously just to ensure we don't mess up later.

    # Congratulations!

    You've seen how to build a basic app, package it as an executable JAR and start it up very quickly. You also saw how Quarkus can run tests continuously to turbocharge your development tasks and facilitate test-driven development. We'll leave the app running and rely on hot reload for the next steps.

    In the next step we'll inject a custom bean to showcase Quarkus' CDI capabilities.
  tabs:
  - title: CLI
    type: terminal
    hostname: crc
  - title: Web Console
    type: service
    hostname: crc
    path: /
    port: 30001
  - title: Visual Editor
    type: code
    hostname: crc
    path: /root
  difficulty: basic
  timelimit: 100
- slug: 02-inject-bean
  id: xqafjcyorgsc
  type: challenge
  title: Step 2
  assignment: |
    In the previous step you created a basic RESTful Java application with Quarkus. In this step we'll add a custom bean that will use the _ArC_ extension which provides a CDI-based dependency injection [solution](https://quarkus.io/guides/cdi-reference.html) tailored for the Quarkus architecture.

    ## Add Custom Bean

    Let’s modify the application and add a companion bean. Open a new file by clicking: `getting-started/src/main/java/org/acme/quickstart/GreetingService.java`.

    Next, click **Copy to Editor** to add the following code to this file:

    <pre class="file" data-filename="./getting-started/src/main/java/org/acme/quickstart/GreetingService.java" data-target="replace">
    package org.acme.quickstart;

    import javax.enterprise.context.ApplicationScoped;

    @ApplicationScoped
    public class GreetingService {

        private String hostname = System.getenv().getOrDefault("HOSTNAME", "unknown");

        public String greeting(String name) {
            return "hello " + name + " from " + hostname;
        }

    }
    </pre>

    Next, open the `getting-started/src/main/java/org/acme/quickstart/GreetingResource.java` class and then click **Copy To Editor** once again to inject the new bean and create a new endpoint using it:

    <pre class="file" data-filename="./getting-started/src/main/java/org/acme/quickstart/GreetingResource.java" data-target="replace">
    package org.acme.quickstart;

    import javax.inject.Inject;
    import javax.ws.rs.GET;
    import javax.ws.rs.Path;
    import javax.ws.rs.PathParam;
    import javax.ws.rs.Produces;
    import javax.ws.rs.core.MediaType;

    @Path("/hello")
    public class GreetingResource {

        @Inject
        GreetingService service;

        @GET
        @Produces(MediaType.TEXT_PLAIN)
        @Path("/greeting/{name}")
        public String greeting(@PathParam("name") String name) {
            return service.greeting(name);
        }

        @GET
        @Produces(MediaType.TEXT_PLAIN)
        public String hello() {
            return "Hello RESTEasy";
        }
    }
    </pre>

    ## Inspect the results

    Since we still have our app running using `mvn quarkus:dev`, when you make these changes and reload the endpoint, Quarkus will notice all of these changes and live reload them.

    Check that it works as expected by loading the new endpoint by [clicking here](https://[[CLIENT_SUBDOMAIN]]-8080-[[KATACODA_HOST]].environments.katacoda.com/hello/greeting/quarkus).

    Note we are exercising our new bean using the `/hello/greeting` endpoint, and you should see

    ```console
    hello quarkus from 4090f59d1a69
    ```

    > In this case, `4090f59d1a69` is the hostname of the local host we are running on. It will be different for you!

    ## Add another test

    Let's add another test for Quarkus to run continously for our new endpoint. Open a new file by clicking: `getting-started/src/test/java/org/acme/quickstart/GreetingServiceTest.java`.

    Next, click **Copy to Editor** to add the following code to this file:

    <pre class="file" data-filename="./getting-started/src/test/java/org/acme/quickstart/GreetingServiceTest.java" data-target="replace">
    package org.acme.quickstart;

    import io.quarkus.test.junit.QuarkusTest;
    import org.junit.jupiter.api.Test;

    import java.util.UUID;

    import static io.restassured.RestAssured.given;
    import static org.hamcrest.CoreMatchers.startsWith;

    @QuarkusTest
    public class GreetingServiceTest {

        @Test
        public void testGreetingEndpoint() {
            String uuid = UUID.randomUUID().toString();
            given()
              .pathParam("name", uuid)
              .when().get("/hello/greeting/{name}")
              .then()
                .statusCode(200)
                .body(startsWith("hello " + uuid));
        }

    }
    </pre>

    This test generates a random string (a UUID), and uses that to call into our new service, looking for the same random name in the returned value.

    You should now see that both tests pass:

    ```
    All 2 tests are passing (0 skipped), 1 tests were run in 429ms. Tests completed at 12:35:33 due to changes to GreetingServiceTest.class.
    ```
    As you add more tests, Quarkus will simply continuously run them to produce the result in realtime.

    ## Congratulations!

    It's a familiar CDI-based environment for you Enterprise Java developers out there, with powerful mechanisms to reload your code _as you type_ (or very close to realtime). In the next step, we'll package and run it as a standalone executable JAR, which should also be familiar to microservice developers.
  tabs:
  - title: CLI
    type: terminal
    hostname: crc
  - title: Web Console
    type: service
    hostname: crc
    path: /
    port: 30001
  - title: Visual Editor
    type: code
    hostname: crc
    path: /root
  difficulty: basic
  timelimit: 100
- slug: 03-package-and-run
  id: npxb5umu42he
  type: challenge
  title: Step 3
  assignment: |+
    In the previous step you added a custom CDI bean to the app. Now it's time to package and run it as a self-contained JAR file.

    ### Stop the previous application

    Let's stop the original application so we can package and re-run it as an executable JAR. In the terminal, press `CTRL-C` to stop the application.

    ### Package the app

    Package the application:

    ```
    mvn package
    ```. It produces 2 jar files:

    * `target/getting-started-1.0.0-SNAPSHOT.jar` - containing just the classes and resources of the projects, it’s the regular artifact produced by the Maven build

    * `target/quarkus-app/quarkus-run.jar` - being an executable jar. Be aware that it’s not an über-jar as the dependencies are copied into several subdirectories (and would need to be included in any layered container image).

    See the files with this command:

    ```
    ls -l target/*.jar target/quarkus-app/*.jar
    ```

    > **NOTE**: Quarkus uses the _fast-jar_ packaging by default. The fast-jar packaging format is introduced as an alternative to the default jar packaging format. The main goal of this new format is to bring faster startup times.

    ## Run the executable JAR

    You can run the packaged application by clicking:

    ```
    java -jar target/quarkus-app/quarkus-run.jar
    ```

    And then test it again using the browser to access the `/hello/greeting` endpoint, passing `quarkus` in the URL using [this link](https://[[CLIENT_SUBDOMAIN]]-8080-[[KATACODA_HOST]].environments.katacoda.com/hello/greeting/quarkus).

    You should see:

    ```console
    hello quarkus from 4090f59d1a69
    ```
    Note the same hostname as before, and also note that since we're running it as a fast-jar, Quarkus runs in production mode (and does not enable continuous testing or other developer features).

    > The `Class-Path` entry of the `MANIFEST.MF` from the _runner jar_ explicitly lists the jars from the subdirectories under `target/quarkus-app`. So if you want to deploy your application somewhere, you need to copy the _runner jar_ as well as the folder structure under `target/quarkus-app`. If you want to create an Uber-jar with everything included, you can use `mvn package -DuberJar`.

    ## Cleanup

    Go back to the terminal and stop the app once again by pressing `CTRL-C`.

    ## Congratulations!

    You've packaged up the app as an executable JAR and learned a bit more about the mechanics of packaging. In the next step, we'll continue our journey and build a _native image_ and then we'll learn about the native executable creation and the packaging in a Linux container.

  tabs:
  - title: CLI
    type: terminal
    hostname: crc
  - title: Web Console
    type: service
    hostname: crc
    path: /
    port: 30001
  - title: Visual Editor
    type: code
    hostname: crc
    path: /root
  difficulty: basic
  timelimit: 100
- slug: 04-build-native
  id: liep5vzlwsis
  type: challenge
  title: Step 4
  assignment: |+
    Let’s now produce a native executable for our application. It improves the startup time of the application, and produces a minimal disk footprint. The executable would have everything to run the application including the "JVM" (shrunk to be just enough to run the application), and the application.

    ![Native process](https://katacoda.com/openshift/assets/middleware/quarkus/native-image-process.png)

    We will be using GraalVM, which includes a native compiler for producing native images for a number of languages, including Java. GraalVM is installed in `$GRAALVM_HOME`:

    ```
    echo $GRAALVM_HOME
    ```

    ## Build native image

    Within the `getting-started/pom.xml` is the declaration for the Quarkus Maven plugin which contains a profile named `native`:

    ```xml

        <profile>
          <id>native</id>
          <activation>
            <property>
              <name>native</name>
            </property>
          </activation>
          <build>
          ...
          <properties>
            <quarkus.package.type>native</quarkus.package.type>
          </properties>
        </profile>

    ```
    We use a profile because, you will see very soon, packaging the native image takes a few seconds. However, this compilation time is only incurred _once_, as opposed to _every_ time the application starts, which is the case with other approaches for building and executing JARs.

    Create a native executable by clicking: ```
    mvn clean package -Pnative -DskipTests
    ```

    > Since we are on Linux in this environment, and the OS that will eventually run our application is also Linux, we can use our local OS to build the native Quarkus app. If you need to build native Linux binaries when on other OS's like Windows or Mac OS X, you can use `-Dquarkus.native.container-runtime=[podman | docker]`. You'll need either Docker or [Podman](https://podman.io) installed depending on which container runtime you want to use!

    This will take a minute or so to finish. Wait for it!

    In addition to the regular files, the build also produces `target/getting-started-1.0.0-SNAPSHOT-runner`. This is a native Linux binary:

    ```
    file target/getting-started-1.0.0-SNAPSHOT-runner
    ```

    ```console
    target/getting-started-1.0.0-SNAPSHOT-runner: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=61109b6a2cc71d269c61b3b964c419c22fbb038b, not stripped
    ```

    ## Run native image

    Since our environment here is Linux, you can _just run it_:

    ```
    target/getting-started-1.0.0-SNAPSHOT-runner
    ```

    Notice the amazingly fast startup time:

    ```console
    INFO  [io.quarkus] (main) Quarkus x.xx.x started in 0.011s. Listening on: http://[::]:8080
    INFO  [io.quarkus] (main) Installed features: [cdi, resteasy]
    ```
    That's 11 milliseconds!

    And extremely low memory usage as reported by the Linux `ps` utility. Click here to run this in your other Terminal tab:

    `ps -o pid,rss,command -p $(pgrep -f runner)`{{execute T2}}

    You should see something like:

    ```console
      PID   RSS COMMAND
     6082 26744 target/getting-started-1.0.0-SNAPSHOT-runner
    ```

    This shows that our process is taking around 26 MB of memory ([Resident Set Size](https://en.wikipedia.org/wiki/Resident_set_size), or RSS). Pretty compact!

    > Note that the RSS and memory usage of any app, including Quarkus, will vary depending your specific environment, and will rise as the application experiences load.

    Make sure the app is still working as expected (we'll use `curl` this time to access it directly):

    `curl http://localhost:8080/hello/greeting/quarkus`{{execute T2}}

    > This will automatically open and run `curl` in a separate terminal. You can also open additional terminals with the "+" button on the tab bar to the right.

    ```console
    curl http://localhost:8080/hello/greeting/quarkus
    hello quarkus from 4090f59d1a69
    ```

    Nice!

    ## Cleanup

    Go to the first Terminal tab and press `CTRL-C` to stop our native app.

    ## Congratulations!

    You've now built a Java application as an executable JAR and a Linux native binary. Now let's give our app superpowers by deploying to OpenShift as a Linux container image.

  tabs:
  - title: CLI
    type: terminal
    hostname: crc
  - title: Web Console
    type: service
    hostname: crc
    path: /
    port: 30001
  - title: Visual Editor
    type: code
    hostname: crc
    path: /root
  difficulty: basic
  timelimit: 100
- slug: 05-deploy-to-openshift
  id: qyzpzfyccatz
  type: challenge
  title: Step 5
  assignment: |+
    Now that we have our app built, let's move it into containers and into the cloud.

    ## Install OpenShift extension

    Quarkus offers the ability to automatically generate OpenShift resources based on sane default and user supplied configuration. The OpenShift extension is actually a wrapper extension that brings together the [kubernetes](https://quarkus.io/guides/deploying-to-kubernetes) and [container-image-s2i](https://quarkus.io/guides/container-image#s2i) extensions with defaults so that it’s easier for the user to get started with Quarkus on OpenShift.

    Run the following command to add it to our project:

    `mvn quarkus:add-extension -Dextensions="openshift"`{{execute T1}}

    ## Login to OpenShift

    We'll deploy our app as the `developer` user. Run the following command to login with the OpenShift CLI:

    `oc login -u developer -p developer`{{execute T1}}

    You should see

    ```
    Login successful.

    You don't have any projects. You can try to create a new project, by running

        oc new-project <projectname>
    ```

    ## Create project

    For this scenario, let's create a project that you will use to house your applications. Click:

    `oc new-project quarkus --display-name="Sample Quarkus App"`{{execute T1}}

    ## Deploy application to OpenShift

    Now let's deploy the application itself. Run the following command which will build and deploy a Quarkus native application using the OpenShift extension (this will take a few minutes to complete as it rebuilds the native executable, generates a container image and pushes it into OpenShift):

    `mvn clean package -Pnative \
    -Dquarkus.kubernetes-client.trust-certs=true \
    -Dquarkus.container-image.build=true \
    -Dquarkus.kubernetes.deploy=true \
    -Dquarkus.kubernetes.deployment-target=openshift \
    -Dquarkus.openshift.expose=true \
    -Dquarkus.openshift.labels.app.openshift.io/runtime=quarkus`{{execute T1}}`

    The output should end with `BUILD SUCCESS`.

    For more details of the above options:

    * `quarkus.kubernetes-client.trust-certs=true` - We are using self-signed certs in this simple example, so this simply says to the extension to trust them.
    * `quarkus.container-image.build=true` - Instructs the extension to build a container image
    * `quarkus.kubernetes.deploy=true` - Instructs the extension to deploy to OpenShift after the container image is built
    * `quarkus.kubernetes.deployment-target=openshift` - Instructs the extension to generate and create the OpenShift resources (like `DeploymentConfig`s and `Service`s) after building the container
    * `quarkus.openshift.expose=true` - Instructs the extension to generate an OpenShift `Route`.
    * `quarkus.openshift.labels.app.openshift.io/runtime=quarkus` - Adds a nice-looking icon to the app when viewing the OpenShift Developer Topology

    Finally, make sure it's actually done rolling out:

    `oc rollout status -w dc/getting-started`{{execute T1}}

    Wait for that command to report following before continuing.
    `replication controller "getting-started-1" successfully rolled out`

    You can also see the app deployed in the [OpenShift Developer Toplogy](https://console-openshift-console-[[HOST_SUBDOMAIN]]-443-[[KATACODA_HOST]].environments.katacoda.com/topology/ns/quarkus):

    You'll need to login with the same credentials as before:

    * Username: `developer`
    * Password: `developer`

    ![topology](https://katacoda.com/openshift/assets/middleware/quarkus/greetingtopology.png)

    So now our app is deployed to OpenShift

    And now we can access using `curl` once again:

    `curl http://getting-started-quarkus.[[HOST_SUBDOMAIN]]-80-[[KATACODA_HOST]].environments.katacoda.com/hello/greeting/quarkus-on-openshift`{{execute T1}}

    You should see:

    ```console
    hello quarkus-on-openshift from getting-started-1-9sgsm
    ```

    > Your pod's name will be different from the above.

    ## Congratulations!

    This step covered the deployment of a Quarkus application on OpenShift. However, there is much more, and the integration with these environments has been tailored to make Quarkus applications execution very smooth. For instance, the health extension can be used for [health check](https://docs.openshift.com/container-platform/4.6/applications/application-health.html); the configuration support allows mounting the application configuration using [config maps](https://docs.openshift.com/container-platform/4.6/authentication/configmaps.html), the metric extension produces data _scrape-able_ by [Prometheus](https://prometheus.io/) and so on.

    But we'll move to the final chapter around scaling and try a few things.


  tabs:
  - title: CLI
    type: terminal
    hostname: crc
  - title: Web Console
    type: service
    hostname: crc
    path: /
    port: 30001
  - title: Visual Editor
    type: code
    hostname: crc
    path: /root
  difficulty: basic
  timelimit: 100
- slug: 06-scaling
  id: v9wxrteqt0hi
  type: challenge
  title: Step 6
  assignment: |
    Now that we have our app running on OpenShift, let's see what we can do.

    ## Restrict resources

    Let's make _sure_ our Quarkus app doesn't go beyond a reasonable amount of memory for each instance by setting _resource constraints_ on it. We'll go with 50 MB of memory as an upper limit (which is pretty thin, compared to your average Java app!). This will let us scale up quite a bit. Click here to set this limit:

    `oc set resources dc/getting-started --limits=memory=50Mi`{{execute T1}}

    ## Scale the app

    With that set, let's see how fast our app can scale up to 10 instances:

    `oc scale --replicas=10 dc/getting-started`{{execute T1}}

    Back in the  [OpenShift Developer Toplogy](https://console-openshift-console-[[HOST_SUBDOMAIN]]-443-[[KATACODA_HOST]].environments.katacoda.com/topology/ns/quarkus) you'll see the app scaling dynamically up to 10 pods:

    ![Scaling](https://katacoda.com/openshift/assets/middleware/quarkus/scaling.png)

    This should only take a few seconds to complete the scaling. Now that we have 10 pods running, let's hit it with some load:

    `for i in {1..50} ; do curl http://getting-started-quarkus.[[HOST_SUBDOMAIN]]-80-[[KATACODA_HOST]].environments.katacoda.com/hello/greeting/quarkus-on-openshift ; sleep .05 ; done`{{execute T1}}

    You can see the 10 instances of our Quarkus app being load-balanced and responding evenly:

    ```console
    hello quarkus-on-openshift from getting-started-2-tfvn4
    hello quarkus-on-openshift from getting-started-2-8f45l
    hello quarkus-on-openshift from getting-started-2-xgg97
    hello quarkus-on-openshift from getting-started-2-8xw8b
    ...
    ```

    > For more fun with load balancing and apps, checkout the [Red Hat Developer Istio Tutorial](https://bit.ly/istio-tutorial) and learn how to control this with much greater precision and flexibility!

    10 not enough? Let's try 50:

    `oc scale --replicas=50 dc/getting-started`{{execute T1}}

    Back in the [Overview in the OpenShift Console](https://[[HOST_SUBDOMAIN]]-8443-[[KATACODA_HOST]].environments.katacoda.com/console/project/quarkus/overview) you'll see the app scaling dynamically up to 50 pods:

    ![Scaling to 50](https://katacoda.com/openshift/assets/middleware/quarkus/50pods.png)

    Once they are all up and running, try the same load again:

    `for i in {1..50} ; do curl http://getting-started-quarkus.[[HOST_SUBDOMAIN]]-80-[[KATACODA_HOST]].environments.katacoda.com/hello/greeting/quarkus-on-openshift ; sleep .05 ; done`{{execute T1}}

    And witness all 50 pods responding evenly to requests. Try doing that with your average Java app running in a container! This tutorial uses a single node OpenShift cluster, but in practice you'll have many more nodes, and can scale to hundreds or thousands of replicas if and when load goes way up.

    > 50 still not enough? Are you feeling lucky? Try **100**: `oc scale --replicas=100 dc/getting-started`{{execute T1}} and watch the magic on the [OpenShift Console](https://[[HOST_SUBDOMAIN]]-8443-[[KATACODA_HOST]].environments.katacoda.com/console/project/quarkus/overview). It may take a bit of time for all 100 to spin up given this limited resource environment, but they will eventually!

    # Open the solution in an IDE in the Cloud!
    Want to continue exploring this solution on your own in the cloud? You can use the free [Red Hat CodeReady Workspaces](https://developers.redhat.com/products/codeready-workspaces/overview) IDE running on the free [Red Hat Developer Sandbox](http://red.ht/dev-sandbox). [Click here](https://workspaces.openshift.com) to login or to register if you are a new user. This free service expires after 30 days, but you can always enable a new free 30-day subscription.

    Once logged in, [click here](https://workspaces.openshift.com/f?url=https://raw.githubusercontent.com/openshift-katacoda/rhoar-getting-started/solution/quarkus/getting-started/devfile.yaml) to open the solution for this project in the cloud IDE. While loading, if it asks you to update or install any plugins, you can say no.

    # Fork the source code to your own GitHub!
    Want to experiment more with the solution code you just worked with? If so, you can fork the repository containing the solution to your own GitHub repository by clicking on the following command to execute it:

    `/root/projects/forkrepo.sh`{{execute T1}}
    - Make sure to follow the prompts. An error saying `Failed opening a web browser at https://github.com/login/device exit status 127` is expected.
    - [Click here](https://github.com/login/device) to open a new browser tab to GitHub and paste in the code you were presented with and you copied.
    - Once done with the GitHub authorization in the browser, close the browser tab and return to the console and press `Enter` to complete the authentication process.
    - If asked to clone the fork, press `n` and then `Enter`.
    - If asked to confirm logout, press `y` and the `Enter`.

       > **NOTE:** This process uses the [GitHub CLI](https://cli.github.com) to authenticate with GitHub. The learn.openshift.com site is not requesting nor will have access to your GitHub credentials.

    After completing these steps the `rhoar-getting-started` repo will be forked in your own GitHub account. On the `solution` branch in the repo, the `getting-started` project inside the `quarkus` folder contains the completed solution for this scenario.

    ## Congratulations

    In this scenario you got a glimpse of the power of Quarkus apps, both traditional JVM-based as well as native builds. There is much more to Quarkus than fast startup times and low resource usage, so keep on exploring additional scenarios to learn more, and be sure to visit [quarkus.io](https://quarkus.io) to learn even more about the architecture and capabilities of this exciting new framework for Java developers.
  tabs:
  - title: CLI
    type: terminal
    hostname: crc
  - title: Web Console
    type: service
    hostname: crc
    path: /
    port: 30001
  - title: Visual Editor
    type: code
    hostname: crc
    path: /root
  difficulty: basic
  timelimit: 100
checksum: "5770780697868036080"
