slug: developing-with-quarkus-qute
id: whkravwkm3hs
type: track
title: Templating with Qute Templating Engine
description: |
  This exercise demonstrates how your Quarkus application can utilize the [Qute Templating Engine](https://quarkus.io/guides/qute) feature to build type-safe, server-side templates which can be rendered at will in Quarkus applications.

  ![Logo](https://katacoda.com/openshift/assets/middleware/quarkus/logo.png)

  Qute is a templating engine designed specifically to meet Quarkus' needs. The usage of reflection is minimized to reduce the size of native images. The API combines both the imperative and the non-blocking reactive style of coding. In the development mode, all files located in `src/main/resources/templates` are watched for changes and modifications are immediately visible. Furthermore, we try to detect most of the template problems at build time. In this exercise, you will learn how to easily render templates in your application.

  The **Qute** engine renders templates (ordinary files with things like `Hello {name}!`). The expression `{name}` embedded in the template is replaced with the value of the corresponding value passed in as context (a simple string, or perhaps a `Map` of key/value pairs). Due to its type-safe goals, the engine will attempt to validate expressions during the build, to catch any errors or typos or other mismatched expressions.

  > Qute is currently an experimental feature in Quarkus. There is no guarantee of stability nor long term presence in the platform until the solution matures.
  >
  > An [introduction guide](https://quarkus.io/guides/qute) and a more comprehensive [reference guide](https://quarkus.io/guides/qute-reference) are available.

  Let's get going!
icon: https://logodix.com/logo/1910931.png
level: beginner
tags:
- openshift
owner: openshift
developers:
- nvinto@redhat.com
- rjarvine@redhat.com
- dahmed@redhat.com
private: false
published: true
challenges:
- slug: 01-basics
  id: fptdziw0xqt1
  type: challenge
  title: Step 1
  notes:
  - type: text
    contents: |
      This exercise demonstrates how your Quarkus application can utilize the [Qute Templating Engine](https://quarkus.io/guides/qute) feature to build type-safe, server-side templates which can be rendered at will in Quarkus applications.

      ![Logo](https://katacoda.com/openshift/assets/middleware/quarkus/logo.png)

      Qute is a templating engine designed specifically to meet Quarkus' needs. The usage of reflection is minimized to reduce the size of native images. The API combines both the imperative and the non-blocking reactive style of coding. In the development mode, all files located in `src/main/resources/templates` are watched for changes and modifications are immediately visible. Furthermore, we try to detect most of the template problems at build time. In this exercise, you will learn how to easily render templates in your application.

      The **Qute** engine renders templates (ordinary files with things like `Hello {name}!`). The expression `{name}` embedded in the template is replaced with the value of the corresponding value passed in as context (a simple string, or perhaps a `Map` of key/value pairs). Due to its type-safe goals, the engine will attempt to validate expressions during the build, to catch any errors or typos or other mismatched expressions.

      > Qute is currently an experimental feature in Quarkus. There is no guarantee of stability nor long term presence in the platform until the solution matures.
      >
      > An [introduction guide](https://quarkus.io/guides/qute) and a more comprehensive [reference guide](https://quarkus.io/guides/qute-reference) are available.

      Let's get going!
  assignment: |-
    # Inspect Java runtime

    An appropriate Java runtime has been installed for you. Ensure you can use it by running this command:

    > If the command fails, wait a few moments and try again (it is installed in a background process and make take a few moments depending on system load).

    ```
    $JAVA_HOME/bin/java --version
    ```

    The command should report the version in use, for example (the versions and dates may be slightly different than the below example):

    ```console
    openjdk 11.0.10 2021-01-19
    OpenJDK Runtime Environment AdoptOpenJDK (build 11.0.10+9)
    OpenJDK 64-Bit Server VM AdoptOpenJDK (build 11.0.10+9, mixed mode)
    ```
    ## Create sample project

    Let's create the basic Quarkus _Hello World_ application and include the necessary qute extensions. Click this command to create the project:

    `cd /root/projects/quarkus &&
     mvn io.quarkus:quarkus-maven-plugin:2.0.0.Final:create \
        -DprojectGroupId=org.acme \
        -DprojectArtifactId=qute \
        -Dextensions="quarkus-resteasy-qute,quarkus-vertx-web,quarkus-qute,quarkus-scheduler"`{{execute T1}}

    > The first time you create an app, new dependencies may be downloaded via maven and take a minute or so. This should only happen once, after that things will go even faster.

    This will use the Quarkus Maven Plugin and generate a sample Qute project for you in the `qute` subdirectory and include the `quarkus-resteasy-qute` extension which includes the templating engine and integration with JAX-RS via RestEasy. We've also included a few other extensions we'll use later on.

    Once generated, look at the `qute/pom.xml`. You will find the import of the Quarkus BOM, allowing to omit the version on the different Quarkus dependencies.

    ## Start the app

    Let's begin Live Coding. Click on the following command to start the example app in _Live Coding_ mode:

    `cd /root/projects/quarkus/qute && \
      mvn quarkus:dev -Dquarkus.http.host=0.0.0.0`{{execute T1}}

    You should see:

    ```console
    __  ____  __  _____   ___  __ ____  ______
     --/ __ \/ / / / _ | / _ \/ //_/ / / / __/
     -/ /_/ / /_/ / __ |/ , _/ ,< / /_/ /\ \
    --\___\_\____/_/ |_/_/|_/_/|_|\____/___/
    INFO  [io.quarkus] (Quarkus Main Thread) qute 1.0.0-SNAPSHOT on JVM (powered by Quarkus x.xx.x.Final) started in x.xxxs. Listening on: http://0.0.0.0:8080
    INFO  [io.quarkus] (Quarkus Main Thread) Profile dev activated. Live Coding activated.
    INFO  [io.quarkus] (Quarkus Main Thread) Installed features: [cdi, mutiny, qute, resteasy, resteasy-qute, scheduler, smallrye-context-propagation, vertx, vertx-web]
    ```

    > The first time you build the app, new dependencies may be downloaded via maven. This should only happen once, after that things will go even faster.

    Note the amazingly fast startup time! The app is now running "locally" (within the Linux container in which this exercise runs).

    Test that the app is running by accessing the sample page [using this link](https://[[CLIENT_SUBDOMAIN]]-8080-[[KATACODA_HOST]].environments.katacoda.com/some-page). You should see

    ![Qute sample](https://katacoda.com/openshift/assets/middleware/quarkus/qute-sample.png)

    This page is rendered using the `qute/src/main/resources/templates/page.qute.html` HTML template. If you look closely you can see a `{name ?: "Qute"}` directive that renders the passed-in `name` query present in the `qute/src/main/java/org/acme/SomePage.java` class and passed into the template renderer in the `data()` method, making the `name` variable available to the renderer and returning the rendered HTML to your browser. If you pass a different name, say, `Jerry` using [this link](https://[[CLIENT_SUBDOMAIN]]-8080-[[KATACODA_HOST]].environments.katacoda.com/some-page?name=Jerry) (which adds `?name=Jerry` to the URL) you'll see the new name rendered via the Qute template:

    ![Qute sample](https://katacoda.com/openshift/assets/middleware/quarkus/qute-sample-jerry.png)

    Let's keep the app running and continue using Quarkus' _Live Coding_ feature. Changes you make are immediately available in the running app when developing Quarkus apps.

    ## Create basic template

    We’ll start by creating a new and very simple text-based template.

    Click `qute/src/main/resources/templates/hello.txt` to create an empty template file.

    Finally, click the **Copy to Editor** to add the template code:

    <pre class="file" data-filename="./qute/src/main/resources/templates/hello.txt" data-target="replace">
    Hello {name}!
    </pre>

    * `{name}` is a _value expression_ that is evaluated when the template is rendered.

    > By default, all files located in the `src/main/resources/templates` directory and its
    > subdirectories are registered as templates. Templates are validated during startup
    > and watched for changes in the development mode.

    ## Create REST endpoint to access template

    Now let’s inject the "compiled" template in the resource class.

    Click here to open `qute/src/main/java/org/acme/HelloResource.java`.

    Click the **Copy to Editor** to update our `HelloResource` class:

    <pre class="file" data-filename="./qute/src/main/java/org/acme/HelloResource.java" data-target="replace">
    package org.acme;

    import javax.inject.Inject;
    import javax.ws.rs.GET;
    import javax.ws.rs.Path;
    import javax.ws.rs.Produces;
    import javax.ws.rs.QueryParam;
    import javax.ws.rs.core.MediaType;

    import io.quarkus.qute.TemplateInstance;
    import io.quarkus.qute.Template;

    @Path("hello")
    public class HelloResource {

        @Inject
        Template hello;

        @GET
        @Produces(MediaType.TEXT_PLAIN)
        public TemplateInstance get(@QueryParam("name") String name) {
            return hello.data("name", name);
        }
    }
    </pre>

    * If there is no `@ResourcePath` qualifier provided when `@Inject`ing, the field name is used to locate the template. In this particular case, we’re injecting a template with path `templates/hello.txt`.
    * `Template.data()` returns a new template instance that can be customized before the actual rendering is triggered. In this case, we put the name value under the key `name`. The data map is accessible during rendering.
    * Note that we don’t trigger the rendering - this is done automatically by a special `ContainerResponseFilter` implementation.

    ## Test endpoint

    With our application already running in _Live Coding_ mode, we can render the template by calling the endpoint. Click the command below to test it:

    `curl http://localhost:8080/hello?name=James`{{execute T2}}

    You should see:

    ```
    Hello James!
    ```
    The template was _rendered_, replacing the `{name}` expression with the value passed in with `hello.data("name", name);`

    This is the basic syntax and idea, which originated with other popular and well-known technologies:

    * The [syntax](https://quarkus.io/guides/qute-reference#syntax-and-building-blocks) is mainly inspired by [Handlebars](https://handlebarsjs.com/) and [Dust.js](https://www.dustjs.com/).
    * [Template inheritance](https://quarkus.io/guides/qute-reference#include_helper) is inspired by [Facelets](https://en.wikipedia.org/wiki/Facelets) and [Django](https://docs.djangoproject.com/en/3.0/ref/templates/language/).
    * Qute supports the [elvis operator](https://en.wikipedia.org/wiki/Elvis_operator) you might be familiar with from [Groovy](https://groovy-lang.org/) and [Kotlin](https://kotlinlang.org/).
    * [Extension methods](https://quarkus.io/guides/qute-reference#template_extension_methods) that can be used to extend the data classes with new functionality are also inspired by modern languages.
    * If you come from the world of JSP/JSF/Facelets you’ll appreciate that `@Named` CDI beans can be referenced directly in any template through the `inject` namespace, e.g. `{inject:foo.price}`. See [Injecting Beans Directly In Templates](https://quarkus.io/guides/qute-reference#injecting-beans-directly-in-templates) for more information.

    Let's now explore some new features based on Quarkus principles.
  tabs:
  - title: CLI
    type: terminal
    hostname: crc
  - title: Web Console
    type: service
    hostname: crc
    path: /
    port: 30001
  - title: Visual Editor
    type: code
    hostname: crc
    path: /root
  difficulty: basic
  timelimit: 150
- slug: 02-typesafe
  id: 4xbqwvrrzkdl
  type: challenge
  title: Step 2
  assignment: |+
    # Type-safe Templates

    There’s an alternate way to declare your templates in your Java code, which relies on the following convention:

    * Organise your template files in the `/src/main/resources/templates` directory, by grouping them into one directory per resource class. So, if your `ItemResource` class references two templates `hello` and `goodbye`, place them at `/src/main/resources/templates/ItemResource/hello.txt` and `/src/main/resources/templates/ItemResource/goodbye.txt`. Grouping templates per resource class makes it easier to navigate to them.

    * In each of your resource class, declare a `@CheckedTemplate static class Template {}` class within your resource class.

    * Declare one `public static native TemplateInstance method();` per template file for your resource.

    * Use those static methods to build your template instances.

    ## Create simple template

    Create a directory to hold templates for our HelloResource class:

    `cd /root/projects/quarkus/qute && mkdir -p src/main/resources/templates/HelloResource`{{execute T2}}

    Next, click to open `qute/src/main/resources/templates/HelloResource/hello.txt`. Click **Copy to Editor** to add the code:

    <pre class="file" data-filename="./qute/src/main/resources/templates/HelloResource/hello.txt" data-target="replace">
    Hello {name} from HelloResource!
    </pre>

    For Goodbye, click to open `qute/src/main/resources/templates/HelloResource/goodbye.txt`. Click **Copy to Editor** to add the code:

    <pre class="file" data-filename="./qute/src/main/resources/templates/HelloResource/goodbye.txt" data-target="replace">
    Goodbye {name} from GoodbyeResource!
    </pre>

    Now let’s declare and use those templates in the resource class. Click **Copy to Editor** to update our `HelloResource` class:

    <pre class="file" data-filename="./qute/src/main/java/org/acme/HelloResource.java" data-target="replace">
    package org.acme;

    import javax.ws.rs.GET;
    import javax.ws.rs.Path;
    import javax.ws.rs.Produces;
    import javax.ws.rs.QueryParam;
    import javax.ws.rs.core.MediaType;

    import io.quarkus.qute.TemplateInstance;
    import io.quarkus.qute.CheckedTemplate;

    @Path("hello")
    public class HelloResource {

        @CheckedTemplate(requireTypeSafeExpressions = false)
        public static class Templates {
            public static native TemplateInstance hello();
            public static native TemplateInstance goodbye();
        }

        @GET
        @Produces(MediaType.TEXT_PLAIN)
        public TemplateInstance get(@QueryParam("name") String name) {
            return Templates.hello().data("name", name);
        }
    }
    </pre>

    * This declares a template with path `templates/HelloResource/hello.txt`, since the `@CheckedTemplate` static class is declared inside the `HelloWorld` class. The name of the method `hello` is used to match files in the directory with common extensions like `.txt`, `.html` etc. You can specify an exact name and path using `@Location`.
    * `Templates.hello()` returns a new template instance that can be customized before the actual rendering is triggered. In this case, we put the name value under the key `name`. The data map is accessible during rendering.
    * Note that we don’t trigger the rendering - this is done automatically by a special `ContainerResponseFilter` implementation.
    * Checked templates require type-safe expressions by default, i.e. expressions that can be validated at build time. It's possible to use `@CheckedTemplate(requireTypeSafeExpressions = false)` to relax this requirement.

    > Once you have declared a `@CheckedTemplate` class, we will check that all its methods point to existing templates, so if you try to use a template from your Java code and you forgot to add it, we will let you know at build time :)

    Keep in mind this style of declaration allows you to reference templates declared in other resources too.

    ## Create Goodbye Resource

    Let's create another resource and reference our `HelloResource.Templates` static class.

    Click to open `qute/src/main/java/org/acme/GoodbyeResource.java` then click **Copy to Editor** to create a new resource:

    <pre class="file" data-filename="./qute/src/main/java/org/acme/GoodbyeResource.java" data-target="replace">
    package org.acme;

    import javax.ws.rs.GET;
    import javax.ws.rs.Path;
    import javax.ws.rs.Produces;
    import javax.ws.rs.QueryParam;
    import javax.ws.rs.core.MediaType;

    import io.quarkus.qute.TemplateInstance;

    @Path("goodbye")
    public class GoodbyeResource {

        @GET
        @Produces(MediaType.TEXT_PLAIN)
        public TemplateInstance get(@QueryParam("name") String name) {
            return HelloResource.Templates.goodbye().data("name", name);
        }
    }
    </pre>

    ## Hello and Goodbye test

    Let's test our new endpoints against the running Quarkus application:

    `curl http://localhost:8080/hello?name=James`{{execute T2}}

    You should see:

    ```
    Hello James from HelloResource!
    ```

    And goodbye:

    `curl http://localhost:8080/goodbye?name=James`{{execute T2}}

    You should see the same:

    ```
    Goodbye James from GoodbyeResource!
    ```

    As stated earlier, since the `TemplateInstance` is declared as an inner class inside of `HelloResource`, Qute will attempt to locate the template in the `HelloResource/` subdirectory. If instead you want to create a top-level declaration, you can do this inside a separate class (do not copy this code for this exercise):

    ```java
    @CheckedTemplate
    public class Templates {
        public static native TemplateInstance hello();
        public static native TemplateInstance goodbye();
    }
    ```
    This will cause Qute to look for the associated `hello.txt` or `goodbye.txt` in the `src/main/resources/templates` directory, instead of `src/main/resources/templates/HelloResource`. It is up to you how you wish to organize your templates.

  tabs:
  - title: CLI
    type: terminal
    hostname: crc
  - title: Web Console
    type: service
    hostname: crc
    path: /
    port: 30001
  - title: Visual Editor
    type: code
    hostname: crc
    path: /root
  difficulty: basic
  timelimit: 150
- slug: 03-parameters
  id: rxd2ojyxj450
  type: challenge
  title: Step 3
  assignment: |+
    # Template Parameter Declarations

    If you declare a parameter declaration in a template, Qute will attempt to validate all expressions that reference this parameter. If an incorrect expression is found the build wil fail. This can greatly reduce developer errors up front. Let's exercise this.

    Create a simple class with two fields by clicking `qute/src/main/java/org/acme/Item.java` to open the file then click **Copy to Editor**:

    <pre class="file" data-filename="./qute/src/main/java/org/acme/Item.java" data-target="replace">
    package org.acme;

    import java.math.BigDecimal;

    public class Item {
        public String name;
        public BigDecimal price;

        public Item(BigDecimal price, String name) {
            this.price = price;
            this.name = name;
        }
    }
    </pre>

    This is a simple `Item` object with two fields (`name` and `price`).

    ## Create Template

    Now, suppose we want to render a simple HTML page that contains the item name and price. First, create a directory by clicking:

    `mkdir -p src/main/resources/templates/ItemResource`{{execute T2}}

    Create a Qute template at by clicking `qute/src/main/resources/templates/ItemResource/item.html` then click the **Copy to Editor** button:

    <pre class="file" data-filename="./qute/src/main/resources/templates/ItemResource/item.html" data-target="replace">
    &lt;!DOCTYPE html&gt;
    &lt;html&gt;
    &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;{item.name}&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;{item.name}&lt;/h1&gt;
        &lt;div&gt;Price: {item.price}&lt;/div&gt;
    &lt;/body&gt;
    &lt;/html&gt;
    </pre>

    ## Create Service

    And create a simple `ItemService` to mock up a database of items. Click `qute/src/main/java/org/acme/ItemService.java` to open the file, then click **Copy To Editor**:

    <pre class="file" data-filename="./qute/src/main/java/org/acme/ItemService.java" data-target="replace">
    package org.acme;

    import java.math.BigDecimal;
    import java.util.HashMap;
    import java.util.Map;
    import javax.enterprise.context.ApplicationScoped;

    @ApplicationScoped
    public class ItemService {

        private Map&lt;Integer, Item&gt; items = Map.of(
            1, new Item(new BigDecimal(1.99), &quot;Apple&quot;),
            2, new Item(new BigDecimal(2.99), &quot;Pear&quot;),
            3, new Item(new BigDecimal(3.99), &quot;Grape&quot;),
            4, new Item(new BigDecimal(129.99), &quot;Mango&quot;)
        );

        public Item findItem(int id) {
            return items.get(id);
        }
    }
    </pre>

    ## Create REST endpoint

    Now create a resource class that uses this type-safe template. Click `qute/src/main/java/org/acme/ItemResource.java` to open the file, then click **Copy To Editor**:

    <pre class="file" data-filename="./qute/src/main/java/org/acme/ItemResource.java" data-target="replace">
    package org.acme;

    import javax.inject.Inject;
    import javax.ws.rs.GET;
    import javax.ws.rs.Path;
    import javax.ws.rs.PathParam;
    import javax.ws.rs.Produces;
    import javax.ws.rs.core.MediaType;

    import io.quarkus.qute.TemplateInstance;
    import io.quarkus.qute.CheckedTemplate;

    @Path("item")
    public class ItemResource {

        @Inject
        ItemService service;

        @CheckedTemplate
        public static class Templates {
            public static native TemplateInstance item(Item item);
        }

        @GET
        @Path("{id}")
        @Produces(MediaType.TEXT_HTML)
        public TemplateInstance get(@PathParam("id") Integer id) {
            return Templates.item(service.findItem(id));
        }
    }
    </pre>

    Here we Declare a static `Templates` inner class with a method called `item()` that gives us a `TemplateInstance` for `templates/ItemResource/item.html` and declare its `Item item` parameter so we can validate the template.

    We then pass the value of `id` to be used to render the template when the REST endpoint is called. Let's try it:

    `curl http://localhost:8080/item/1`{{execute T2}}

    You should see an HTML result that shows Apple (`id=1`) and its price:

    ```html
    <body>
        <h1>Apple</h1>
        <div>Price: 1.9899999999999999911182158029987476766109466552734375</div>
    </body>
    ```

    You can also [click here](https://[[CLIENT_SUBDOMAIN]]-8080-[[KATACODA_HOST]].environments.katacoda.com/item/1) to see an actual HTML rendering in your browser:

    ![Apple](https://katacoda.com/openshift/assets/middleware/quarkus/qute-apple.png)

    ## Template parameter declaration inside the template

    Alternatively, to declare that a template is expecting an `Item` type, you can declare it in the template file itself to add additional type and parameter checking and simplify the code while still maintaining type checking. Let's update our HTML template a bit. Click **Copy to Editor** to update the template:

    <pre class="file" data-filename="./qute/src/main/resources/templates/ItemResource/item.html" data-target="replace">
    {@org.acme.Item item}
    &lt;!DOCTYPE html&gt;
    &lt;html&gt;
    &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;{item.name}&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;{item.name}&lt;/h1&gt;
        &lt;div&gt;Price: {item.price}&lt;/div&gt;
    &lt;/body&gt;
    &lt;/html&gt;
    </pre>

    Notice the first line - this ia an _optional_ parameter declaration. If declared, Qute attempts to validate all expressions that reference the parameter `item`.

    Now update the resource class to use the simpler way to inject templates:

    <pre class="file" data-filename="./qute/src/main/java/org/acme/ItemResource.java" data-target="replace">
    package org.acme;

    import javax.inject.Inject;
    import javax.ws.rs.GET;
    import javax.ws.rs.Path;
    import javax.ws.rs.PathParam;
    import javax.ws.rs.Produces;
    import javax.ws.rs.core.MediaType;

    import io.quarkus.qute.TemplateInstance;
    import io.quarkus.qute.Location;
    import io.quarkus.qute.Template;

    @Path("item")
    public class ItemResource {

        @Inject
        ItemService service;

        @Inject
        @Location("ItemResource/item")
        Template item;

        @GET
        @Path("{id}")
        @Produces(MediaType.TEXT_HTML)
        public TemplateInstance get(@PathParam("id") Integer id) {
            return item.data("item", service.findItem(id));
        }
    }
    </pre>

    Test it out again using the same process: [click here](https://[[CLIENT_SUBDOMAIN]]-8080-[[KATACODA_HOST]].environments.katacoda.com/item/1) to see an actual HTML rendering in your browser:

    ![Apple](https://katacoda.com/openshift/assets/middleware/quarkus/qute-apple.png)

    It's the same value, but with additional checking in the template itself. If you made any errors, you'll see it immediately in the rendered output (the live coding rebuild will fail).

    If you did not see errors, congratulations! But let's see what happens if we do. Click here: `qute/src/main/resources/templates/ItemResource/item.html` to open the template. Change `{item.name}` to `{item.nonSense}`. Now click here to [reload](https://[[CLIENT_SUBDOMAIN]]-8080-[[KATACODA_HOST]].environments.katacoda.com/item/1). You should get an error:

    ![Err](https://katacoda.com/openshift/assets/middleware/quarkus/qute-err.png)

    Qute checks the syntax and will fail the build (and result in a prettified HTML error screen) when syntax errors are detected in the template. This makes it very easy to quickly iterate, update code and template, and see the results.

    # Before moving on

    Be sure to change the value back to `{item.name}`!

  tabs:
  - title: CLI
    type: terminal
    hostname: crc
  - title: Web Console
    type: service
    hostname: crc
    path: /
    port: 30001
  - title: Visual Editor
    type: code
    hostname: crc
    path: /root
  difficulty: basic
  timelimit: 150
- slug: 04-extensions
  id: 7l1bnmupgpba
  type: challenge
  title: Step 4
  assignment: |+
    # Template Extension Methods

    **Template extension methods** are used to extend the set of accessible properties of data objects.

    Sometimes, you’re not in control of the classes that you want to use in your template, and you cannot add methods to them. Template extension methods allows you to declare new method for those classes that will be available from your templates just as if they belonged to the target class.

    Let’s keep extending on our simple HTML page that contains the item name, price and add a discounted price. The discounted price is sometimes called a "computed property". We will implement a template extension method to render this property easily. Let’s update our template. Click **Copy to Editor** to update the template with computed properties:

    <pre class="file" data-filename="./qute/src/main/resources/templates/ItemResource/item.html" data-target="replace">
    &lt;!DOCTYPE html&gt;
    &lt;html&gt;
    &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;{item.name}&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;{item.name}&lt;/h1&gt;
        &lt;div&gt;Price: {item.price}&lt;/div&gt;
        {#if item.price &gt; 100}
        &lt;div&gt;Discounted Price: {item.discountedPrice}&lt;/div&gt;
        {/if}
    &lt;/body&gt;
    &lt;/html&gt;
    </pre>

    Notice the use of Handlebar-esque `{#if ...}`. It's part of Qute's basic control flow features.

    Also notice the use of `{item.discountedPrice}`. This field does not exist in our `Item` class (which only has `name` and `price`). We'll add an _extension_ to our java code to make this property be available to the template, and write the code that computes its value in Java.

    Click `qute/src/main/java/org/acme/TemplateExtensions.java` to open the new file.

    Click **Copy to Editor** to create the extensions class where we'll declare our `discountedPrice`:

    <pre class="file" data-filename="./qute/src/main/java/org/acme/TemplateExtensions.java" data-target="replace">
    package org.acme;

    import java.math.BigDecimal;
    import io.quarkus.qute.TemplateExtension;

    @TemplateExtension
    public class TemplateExtensions {

        public static BigDecimal discountedPrice(Item item) {
            return item.price.multiply(new BigDecimal("0.9"));
        }
    }
    </pre>

    Here we declare a static template extension method that can be used to add "computed properties" to a data class. The class of the first parameter (in this case `Item`) is used to match the base object and the method name is used to match the property name (in this case `discountedPrice`). When we declare `{item.discountedPrice}`, the contextual value of `item` is passed to this `discountedPrice` method to compute its value (where we use the `item.price.multiply()` method to apply a 10% discount by multiplying by `0.9`).

    > You can place template extension methods in every class if you annotate them with `@TemplateExtension` but we advise to keep them either grouped by target type, or in a single `TemplateExtensions` class by convention.

    [Click here](https://[[CLIENT_SUBDOMAIN]]-8080-[[KATACODA_HOST]].environments.katacoda.com/item/1) to reload the page and see the result for Apples:

    ![Apple](https://katacoda.com/openshift/assets/middleware/quarkus/qute-apple.png)

    Since Apples cost less than $100, no discount for you (you won't see the discounted price)! But [try with Mangos](https://[[CLIENT_SUBDOMAIN]]-8080-[[KATACODA_HOST]].environments.katacoda.com/item/4).

    ![Mango](https://katacoda.com/openshift/assets/middleware/quarkus/qute-mango.png)

    What a deal!

  tabs:
  - title: CLI
    type: terminal
    hostname: crc
  - title: Web Console
    type: service
    hostname: crc
    path: /
    port: 30001
  - title: Visual Editor
    type: code
    hostname: crc
    path: /root
  difficulty: basic
  timelimit: 150
- slug: 05-periodic
  id: b73wb6svypqy
  type: challenge
  title: Step 5
  assignment: |
    # Rendering Periodic Reports

    Templating engines can be also very useful when rendering periodic reports. We will use the `quarkus-scheduler` extension which you've already added.

    ## Create Samples

    Now let's create a simple `Sample` object that represents a point-in-time of a value (maybe ambient temperature or blood pressure of a patient):

    Click `qute/src/main/java/org/acme/Sample.java` to open the file. Click **Copy to Editor** to paste in the code:

    <pre class="file" data-filename="./qute/src/main/java/org/acme/Sample.java" data-target="replace">
    package org.acme;

    public class Sample {
        public boolean valid;
        public String name;
        public String data;

        public Sample(boolean valid, String name, String data) {
            this.valid = valid;
            this.name = name;
            this.data = data;
        }

    }
    </pre>

    Now let's ceate a service whose `get()` method returns a random list of samples. Open the file with `qute/src/main/java/org/acme/SampleService.java` and click **Copy to Editor** to create the code:

    <pre class="file" data-filename="./qute/src/main/java/org/acme/SampleService.java" data-target="replace">
    package org.acme;

    import java.util.List;
    import java.util.Random;
    import java.util.stream.Collectors;
    import java.util.stream.IntStream;

    import javax.enterprise.context.ApplicationScoped;

    @ApplicationScoped
    public class SampleService {
        private static final String[] names = {&quot;James&quot;, &quot;Deepak&quot;, &quot;Daniel&quot;, &quot;Shaaf&quot;, &quot;Jeff&quot;, &quot;Sally&quot;};

        public List&lt;Sample&gt; get() {
            int count = new Random().nextInt(10);
            return IntStream.range(0, count)
                .mapToObj(idx -&gt; Math.random() &gt; 0.5)
                .map(valid -&gt; new Sample(valid, names[(int)(Math.random() * names.length)], Math.random() + &quot;&quot;))
                .collect(Collectors.toList());
        }
    }
    </pre>

    ## Create Template

    Let's make a directory to house our new template with this command:

    `mkdir -p src/main/resources/templates/reports/v1`{{execute T2}}

    Click `qute/src/main/resources/templates/reports/v1/report_01.json.template` to open the new file.

    Click **Copy to Editor** to create the template. We'll place it in the `src/main/resources/templates/reports/v1` path to simulate some sort of organization of different reports:

    <pre class="file" data-filename="./qute/src/main/resources/templates/reports/v1/report_01.json.template" data-target="replace">
    \{
        "time": "{now}",
        "samples": [
          {#for sample in samples}
          \{"name": "{sample.name ?: 'Unknown'}","data": "{#if sample.valid}{sample.data}{#else}--Invalid--{/if}"}{#if count < samples.size },{/if}
          {/for}
        ]
      }
    </pre>

    Here we are looping over the passed-in `samples`. You can iterate over `Iterable`s, `Map`s and `Stream`s. Since we are rendering JSON, we also need to escape the first of any pair of JSON-related `}` or `{` using `\}` or `\{`.

    Also note the use of the [elvis operator](https://en.wikipedia.org/wiki/Elvis_operator) `{sample.name ?: 'Unknown'}` - if the name is `null` the default value `Unknown` is used.

    ## Create periodic reports

    Create the ReportGenerator file by clicking `qute/src/main/java/org/acme/ReportGenerator.java`.

    And finally click **Copy to Editor** to add code that uses all of the above and generates reports periodically to a file in `/tmp`:

    <pre class="file" data-filename="./qute/src/main/java/org/acme/ReportGenerator.java" data-target="replace">
    package org.acme;

    import java.io.FileWriter;

    import javax.enterprise.context.ApplicationScoped;
    import javax.enterprise.event.Observes;
    import javax.inject.Inject;

    import io.quarkus.qute.Template;
    import io.quarkus.qute.Location;
    import io.quarkus.runtime.ShutdownEvent;
    import io.quarkus.runtime.StartupEvent;
    import io.quarkus.scheduler.Scheduled;

    @ApplicationScoped
    public class ReportGenerator {

        @Inject
        SampleService service;

        private FileWriter fout = null;

        @Location("reports/v1/report_01.json.template")
        Template report;

        @Scheduled(cron="* * * ? * *")
        void generate() throws Exception {
            String result = report
                .data("samples", service.get())
                .data("now", java.time.LocalDateTime.now())
                .render();
                System.out.println("report: " + result);
            if (fout != null) {
                fout.write(result + "\n");
                fout.flush();
            }

        }

        void onStart(@Observes StartupEvent ev) throws Exception {
            fout = new FileWriter("/tmp/report.json", true);
        }
        void onShutdown(@Observes ShutdownEvent ev) throws Exception {
            fout.close();
            fout = null;
        }
    }
    </pre>

    * In this case, we use the `@ResourcePath` qualifier to specify the template path: `templates/reports/v1/report_01.json`.
    * Use the `@Scheduled` annotation to instruct Quarkus to execute this method every second. For more information see the [Scheduler](https://quarkus.io/guides/scheduler) guide.
    * The `TemplateInstance.render()` method triggers rendering. Note that this method blocks the current thread.
    * We use Quarkus' `StartupEvent` and `ShutdownEvent` to manage the File I/O on startup and shutdown

    To trigger report to start generating (by triggering Quarkus Live Reload), click to run this command and access the `hello` endpoint:

    `curl http://localhost:8080/hello?name=James`{{execute T2}}

    Assuming no errors, our reports should generate every second. Let's `tail` the file:

    `tail -f /tmp/report.json`{{execute T2}}

    You should see new reports every second. When done, don't forget to type `CTRL-C` to stop the `tail -f`!
  tabs:
  - title: CLI
    type: terminal
    hostname: crc
  - title: Web Console
    type: service
    hostname: crc
    path: /
    port: 30001
  - title: Visual Editor
    type: code
    hostname: crc
    path: /root
  difficulty: basic
  timelimit: 150
- slug: 06-reactive
  id: xavnxsw7yfko
  type: challenge
  title: Step 6
  assignment: |+
    # Reactive and Asynchronous APIs

    Quarkus is _reactive_. If you look under the hood, you will find a reactive engine powering your Quarkus application. This engine is [Eclipse Vert.x](https://vertx.io). Every IO interaction passes through the non-blocking and reactive Vert.x engine. All the HTTP requests your application receives are handled by event loops (IO Thread) and then are routed towards the code that manages the request. Depending on the destination, it can invoke the code managing the request on a worker thread (Servlet, Jax-RS) or use the IO Thread (reactive route). [Mutiny](https://github.com/smallrye/smallrye-mutiny) is a reactive programming library allowing to express and compose asynchronous actions.

    Qute Templates can be asynchronously rendered as a `CompletionStage<String>` (completed with the rendered output asynchronously) or as `Publisher<String>` containing the rendered chunks.

    If these are returned in an REST endpoint, the endpoint will be processed asynchronously, saving compute resources by not creating many threads to handle requests. Let's compare both types by creating a traditional (blocking) endpoint, and an async endpoint.

    Quarkus [Reactive routes](https://quarkus.io/guides/reactive-routes) propose an alternative approach to implement HTTP endpoints where you declare and chain routes. This approach became very popular in the JavaScript world, with frameworks like Express.Js or Hapi. Quarkus also offers the possibility to use reactive routes. You can implement REST API with routes only or combine them with JAX-RS resources and servlets.

    ## Create reactive Report Generator

    You've already added the `quarkus-vertx-web` extension which gives us the ability to declare Reactive Routes.

    Click `qute/src/main/java/org/acme/ReactiveResource.java` to open a new file.

    Click **Copy to Editor** to create create a reactive route that will process our Qute template:

    <pre class="file" data-filename="./qute/src/main/java/org/acme/ReactiveResource.java" data-target="replace">
    package org.acme;

    import io.quarkus.qute.Template;
    import io.quarkus.qute.Location;
    import io.quarkus.vertx.web.Route;
    import io.quarkus.vertx.web.RoutingExchange;
    import javax.enterprise.context.ApplicationScoped;
    import javax.inject.Inject;
    import javax.ws.rs.core.MediaType;

    @ApplicationScoped
    public class ReactiveResource {

        @Inject
        SampleService service;

        @Location(&quot;reports/v1/report_01.json.template&quot;)
        Template report;

        @Route(path = &quot;/reactive&quot;, methods = Route.HttpMethod.GET, produces = MediaType.APPLICATION_JSON)
        void reactive(RoutingExchange ex) throws Exception {
            report
              .data(&quot;samples&quot;,service.get())
              .data(&quot;now&quot;, java.time.LocalDateTime.now())
              .renderAsync()
              .thenAccept((val) -&gt; ex.ok(val));
        }
    }
    </pre>

    * The `@Route` annotation indicates that the method is a reactive route. Again, by default, the code contained in the method must not block.
    * Note the use of the Qute `.renderAsync()` method - this method will be completed with the rendered template asynchronously.
    * The method gets a `RoutingExchange` as a parameter. `RoutingExchange` is a convenient wrapper of `RoutingContext` which provides some useful methods. With `RoutingContext` you can retrieve the HTTP request (using `request()`) and write the response using `response().end(…​)`.

    More details about using the RoutingContext is available in the [Vert.x Web documentation](https://vertx.io/docs/vertx-web/java/).

    ## Test endpoint

    Make sure the endpoint generates a report. Click the following command to try it:

    `curl http://localhost:8080/reactive`{{execute T2}}

    You should see a random report of the samples from earlier, but done so with a _Reactive Route_.

    To learn more about Quarkus and reactive programming, check out the [Reactive Programming with Quarkus Reactive SQL exercise](https://learn.openshift.com/middleware/courses/middleware-quarkus/reactive-sql).

    # Open the solution in an IDE in the Cloud!
    Want to continue exploring this solution on your own in the cloud? You can use the free [Red Hat CodeReady Workspaces](https://developers.redhat.com/products/codeready-workspaces/overview) IDE running on the free [Red Hat Developer Sandbox](http://red.ht/dev-sandbox). [Click here](https://workspaces.openshift.com) to login or to register if you are a new user. This free service expires after 30 days, but you can always enable a new free 30-day subscription.

    Once logged in, [click here](https://workspaces.openshift.com/f?url=https://raw.githubusercontent.com/openshift-katacoda/rhoar-getting-started/solution/quarkus/qute/devfile.yaml) to open the solution for this project in the cloud IDE. While loading, if it asks you to update or install any plugins, you can say no.

    # Fork the source code to your own GitHub!
    Want to experiment more with the solution code you just worked with? If so, you can fork the repository containing the solution to your own GitHub repository by clicking on the following command to execute it:

    `/root/projects/forkrepo.sh`{{execute T1}}
    - Make sure to follow the prompts. An error saying `Failed opening a web browser at https://github.com/login/device exit status 127` is expected.
    - [Click here](https://github.com/login/device) to open a new browser tab to GitHub and paste in the code you were presented with and you copied.
    - Once done with the GitHub authorization in the browser, close the browser tab and return to the console and press `Enter` to complete the authentication process.
    - If asked to clone the fork, press `n` and then `Enter`.
    - If asked to confirm logout, press `y` and the `Enter`.

       > **NOTE:** This process uses the [GitHub CLI](https://cli.github.com) to authenticate with GitHub. The learn.openshift.com site is not requesting nor will have access to your GitHub credentials.

    After completing these steps the `rhoar-getting-started` repo will be forked in your own GitHub account. On the `solution` branch in the repo, the `qute` project inside the `quarkus` folder contains the completed solution for this scenario.

    # Wrap-up

    Congratulations! Qute provides a powerful, flexible, type-safe and reactive way to render templates using ideas and mechanisms familiar to Java developers. To learn more about Qute, please refer to the [Qute reference guide](https://quarkus.io/guides/qute-reference).


  tabs:
  - title: CLI
    type: terminal
    hostname: crc
  - title: Web Console
    type: service
    hostname: crc
    path: /
    port: 30001
  - title: Visual Editor
    type: code
    hostname: crc
    path: /root
  difficulty: basic
  timelimit: 150
checksum: "16696876846050192853"
