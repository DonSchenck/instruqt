slug: developing-with-spring-monitoring
id: heouzx78joia
type: track
title: Monitoring Spring Applications on OpenShift
description: In this scenario you will learn more about developing Spring Boot applications using the [Red Hat Runtimes](https://www.redhat.com/en/products/runtimes) platform. You will learn about how OpenShift uses monitoring tools to keep your application running / notify you when something unrecoverable happens through the use of *probes* .
icon: https://logodix.com/logo/1910931.png
level: beginner
tags:
- openshift
owner: openshift
developers:
- nvinto@redhat.com
- rjarvine@redhat.com
- dahmed@redhat.com
private: false
published: true
challenges:
- slug: 01-review-the-initial-project
  id: bxbrzrrsyipp
  type: challenge
  title: Step 1
  notes:
  - type: text
    contents: In this scenario you will learn more about developing Spring Boot applications using the [Red Hat Runtimes](https://www.redhat.com/en/products/runtimes) platform. You will learn about how OpenShift uses monitoring tools to keep your application running / notify you when something unrecoverable happens through the use of *probes* .
  assignment: |
    # Import the code

    Let's refresh the code we'll be using. Run the following command to clone the sample project:

    ```
    cd /root/projects && rm -rf rhoar-getting-started && git clone https://github.com/openshift-katacoda/rhoar-getting-started && cd rhoar-getting-started/spring/spring-monitoring
    ```

    # Review the base structure of the application

    For your convenience, this scenario has been created with a base project using the Java programming language and the Apache Maven build tool.

    As you review the content, you will notice that there are a couple **TODO** comments. **Do not remove them!** These comments are used as markers for later exercises in this scenario. Open ``src/main/java/com/example/service/FruitController.java``. This is our rest controller. We will be adding our logging commands here later in this module.

    **1. Test the application locally**

    As we develop the application we want to be able to test and verify our change at different stages. One way we can do that locally is by using the `spring-boot` maven plugin.

    Run the application by executing the following command:

    ```
    mvn spring-boot:run
    ```

    Once that's completed, click on the **Local Web Browser** tab and navigate to the `/fruits` endpoint or use [this](https://[[CLIENT_SUBDOMAIN]]-8080-[[KATACODA_HOST]].environments.katacoda.com/fruits) link.

    You should now see an HTML page with a `Success` welcome message that looks like this:

    ![Success](https://katacoda.com/openshift/assets/middleware/rhoar-monitoring/landingPage.png)

    If you see this then you've successfully set up the application! If not check the logs in the terminal. Spring Boot adds a couple helper layers to catch common errors and print helpful messages to the console so check for those first.

    **2. Stop the application**

    Before moving on, click in the terminal window and then press <kbd>CTRL</kbd>+<kbd>C</kbd> to stop the running application!

    ## Congratulations

    You have now successfully executed the first step in this scenario. In the next step we will login to OpenShift and create a new project.
  tabs:
  - title: CLI
    type: terminal
    hostname: crc
  - title: Web Console
    type: service
    hostname: crc
    path: /
    port: 30001
  - title: Visual Editor
    type: code
    hostname: crc
    path: /root
  difficulty: basic
  timelimit: 300
- slug: 02-deploy-to-openshift
  id: 9cwxogkbpbsk
  type: challenge
  title: Step 2
  assignment: |-
    # Deploy to OpenShift Application Platform
    **1. Deploying the application to OpenShift**

    This sandbox has already authenticated you to OpenShift. To validate, we will use the `oc whoami` command:

    ```
    oc whoami
    ```

    Let's create a project that you will use to house your applications.

    ```
    oc new-project dev --display-name="Dev - Spring Boot App"
    ```

    Run the following command to deploy the application to OpenShift:

    ```
    mvn package oc:deploy -Popenshift -DskipTests
    ```

    This step may take some time to do the Maven build and the OpenShift deployment. After the build completes you can verify that everything is started by running the following command:

    ```
    oc rollout status dc/spring-monitoring
    ```

    **2. Using a Route to reach the application from the internet**

    Now that our application is deployed to OpenShift, how do external users access it? The answer is with a **Route**. By using a route, we are able to expose our services and allow for external connections at a given hostname. Open the OpenShift Console, log in using _admin_/_admin_ credetial and you can view the route that was created for our application under the project _dev_.
    ![Routes](https://katacoda.com/openshift/assets/middleware/rhoar-monitoring/routes.png)

    Either click on the route link through the _Location_ column from the above screen and navigate to the `/fruits` endpoint, or click this link [here](http://spring-monitoring-dev.[[HOST_SUBDOMAIN]]-80-[[KATACODA_HOST]].environments.katacoda.com/fruits).

    We should now see the same `Success` page that we saw when we first tested our app locally:

    ![Success](https://katacoda.com/openshift/assets/middleware/rhoar-monitoring/landingPage.png)

    ## Congratulations

    You have now learned how to access the application via an external route. In our next step, we will navigate through OpenShift's web console in order to view our application and learn about health checks.
  tabs:
  - title: CLI
    type: terminal
    hostname: crc
  - title: Web Console
    type: service
    hostname: crc
    path: /
    port: 30001
  - title: Visual Editor
    type: code
    hostname: crc
    path: /root
  difficulty: basic
  timelimit: 300
- slug: 03-add-health-checks
  id: qcqjksliao7y
  type: challenge
  title: Step 3
  assignment: |
    # Implementing Health Checks

    Now that our project has been deployed to OpenShift and we've verified that we're able to hit our endpoint, it's time to add a health check to the application.

    **1. View Health Checks**

    Our application is now up and running on OpenShift and accessible to all users. However how do we handle an application failure? Without constantly manually veriifying the application there would be no way to know when the application crashes. Luckily OpenShift can handle this issue by using probes.

    There are two types of probes that we can create; a `liveness probe` and a `readiness probe`. Liveness probes are used to check if the container is still running. Readiness probes are used to determine if containers are ready to service requests. We're going to be creating a health check, which is a liveness probe that we'll use to keep track of our application health.

    Our health check will continually poll the application to ensure that the application is up and healthy. If the check fails, OpenShift will be alerted and will restart the container and spin up a brand new instance. You can read more about the specifics [here](https://docs.openshift.com/container-platform/4.7/applications/application-health.html).

    Since a lack of health checks can cause container issues if they crash, OpenShift will alert you with a warning message if your project is lacking one.

    Switch to the 'developer' perspective and from the _Topology_ tab of your project _dev_, select your deployment. You should see something like this:

    ![Missing Health Checks](https://katacoda.com/openshift/assets/middleware/rhoar-monitoring/healthChecks.png)


    Since we have a Spring Boot application we have an easy option for implementation of health checks. We're able to pull in the `Spring Actuator` library.

    **2. Add Health Checks with Actuator**

    Spring Actuator is a project which exposes health data under the API path `/actuator/health` that is collected during application runtime automatically. All we need to do to enable this feature is to add the following dependency to ``pom.xml`` at the **TODO** comment..

    <pre class="file" data-filename="pom.xml" data-target="insert" data-marker="<!-- TODO: Add Actuator dependency here -->">
        &lt;dependency&gt;
          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
          &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
    </pre>

    Notice how the previous warning message from before regarding missing health checks is no longer present. This is because of the dependency that we just added to ourt `pom.xml`. Adding this dependency triggers jkube to create Readiness/Liveness probes for OpenShift. These probes will periodically query the new health endpoints to make sure the app is still up.

    Run the following command again to re-deploy the application to OpenShift:

    ```
    mvn package oc:deploy -Popenshift -DskipTests
    ```

    Now that we've added Spring Actuator, we're able to hit their provided `/actuator/health` endpoint. We can navigate to it by either adding `/actuator/health` to our landing page, or by clicking [here](http://spring-monitoring-dev.[[HOST_SUBDOMAIN]]-80-[[KATACODA_HOST]].environments.katacoda.com/actuator/health)

    We should now see the following response, confirming that our application is up and running properly:

    ```json
    {"status":"UP"}
    ```

    OpenShift will now continuously poll this endpoint to determine if any action is required to maintain the health of our container.

    **3.Other Spring Actuator endpoints for monitoring**

    The `/actuator/health` endpoint isn't the only endpoint that Spring Actuator provides out of the box. We're going to take a closer look at a few of the different endpoints so we can see how they help us with monitoring our newly deployed application, specifically the `/metrics` and `/beans` endpoints. A list of all other Spring Actuator endpoints can be found [here](https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html).

    Unlike the `/actuator/health` endpoint some of these endpoints can return sensitive information and require authentication. For simplicity purposes we will be removing this security requirement in order to hit the endpoints, but this is not recommended for a production environment with sensitive data. Pull up the application.properties file ``src/main/resources/application.properties`` and add this code to disable endpoint security.

    <pre class="file" data-filename="src/main/resources/application.properties" data-target="insert" data-marker="# TODO: Add Security preference here">
    management.endpoints.web.exposure.include=*
    </pre>

    If we redeploy the application again with:

    ```
    mvn package oc:deploy -Popenshift -DskipTests
    ```

    Now we can hit the `/actuator/metrics` endpoint [here](http://spring-monitoring-dev.[[HOST_SUBDOMAIN]]-80-[[KATACODA_HOST]].environments.katacoda.com/actuator/metrics) and get a list of metrics types accessible to us:

    ```json
    {"names":["jvm.memory.max","jvm.threads.states","process.files.max","jvm.gc.memory.promoted","system.load.average.1m","jvm.memory.used","jvm.gc.max.data.size","jvm.memory.committed","system.cpu.count","logback.events","http.server.requests","tomcat.global.sent","jvm.buffer.memory.used","tomcat.sessions.created","jvm.threads.daemon","system.cpu.usage","jvm.gc.memory.allocated","tomcat.global.request.max","tomcat.global.request","tomcat.sessions.expired","jvm.threads.live","jvm.threads.peak","tomcat.global.received","process.uptime","tomcat.sessions.rejected","process.cpu.usage","tomcat.threads.config.max","jvm.classes.loaded","jvm.classes.unloaded","tomcat.global.error","tomcat.sessions.active.current","tomcat.sessions.alive.max","jvm.gc.live.data.size","tomcat.threads.current","process.files.open","jvm.buffer.count","jvm.gc.pause","jvm.buffer.total.capacity","tomcat.sessions.active.max","tomcat.threads.busy","process.start.time"]}
    ```

    We can then navigate to `/acutuator/metrics/[metric-name]`. For example, click this link: [JVM Memory Usage](http://spring-monitoring-dev.[[HOST_SUBDOMAIN]]-80-[[KATACODA_HOST]].environments.katacoda.com/actuator/metrics/jvm.memory.max).
    This will display different types of metric data about the JVM Metrics:

    ```json
    {"name":"jvm.memory.max","description":"The maximum amount of memory in bytes that can be used for memory management","baseUnit":"bytes","measurements":[{"statistic":"VALUE","value":2.543321088E9}],"availableTags":[{"tag":"area","values":["heap","nonheap"]},{"tag":"id","values":["Compressed Class Space","PS Survivor Space","PS Old Gen","Metaspace","PS Eden Space","Code Cache"]}]}
    ```

    In addition to the different monitoring endpoints we also have informational endpoints like the `/actuator/beans` endpoint [here](http://spring-monitoring-dev.[[HOST_SUBDOMAIN]]-80-[[KATACODA_HOST]].environments.katacoda.com/actuator/beans), which will show all of the configured beans in the application. Spring Actuator provides multiple informational endpoints on top of the monitoring endpoints that can prove useful for information gathering about your deployed Spring application and can be helpful while debugging your applications in OpenShift.

    # Open the solution in an IDE in the Cloud!
    Want to continue exploring this solution on your own in the cloud? You can use the free [Red Hat CodeReady Workspaces](https://developers.redhat.com/products/codeready-workspaces/overview) IDE running on the free [Red Hat Developer Sandbox](http://red.ht/dev-sandbox). [Click here](https://workspaces.openshift.com) to login or to register if you are a new user. This free service expires after 30 days, but you can always enable a new free 30-day subscription.

    Once logged in, [click here](https://workspaces.openshift.com/f?url=https://raw.githubusercontent.com/openshift-katacoda/rhoar-getting-started/solution/spring/spring-monitoring/devfile.yaml) to open the solution for this project in the cloud IDE. While loading, if it asks you to update or install any plugins, you can say no.

    # Fork the source code to your own GitHub!
    Want to experiment more with the solution code you just worked with? If so, you can fork the repository containing the solution to your own GitHub repository by clicking on the following command to execute it:

    `/root/projects/forkrepo.sh`{{execute T1}}
    - Make sure to follow the prompts. An error saying `Failed opening a web browser at https://github.com/login/device exit status 127` is expected.
    - [Click here](https://github.com/login/device) to open a new browser tab to GitHub and paste in the code you were presented with and you copied.
    - Once done with the GitHub authorization in the browser, close the browser tab and return to the console and press `Enter` to complete the authentication process.
    - If asked to clone the fork, press `n` and then `Enter`.
    - If asked to confirm logout, press `y` and the `Enter`.

       > **NOTE:** This process uses the [GitHub CLI](https://cli.github.com) to authenticate with GitHub. The learn.openshift.com site is not requesting nor will have access to your GitHub credentials.

    After completing these steps the `rhoar-getting-started` repo will be forked in your own GitHub account. On the `solution` branch in the repo, the `spring-monitoring` project inside the `spring` folder contains the completed solution for this scenario.

    ## Congratulations

    You have now included a health check in your Spring Boot application that's living in the OpenShift Container Platform.
  tabs:
  - title: CLI
    type: terminal
    hostname: crc
  - title: Web Console
    type: service
    hostname: crc
    path: /
    port: 30001
  - title: Visual Editor
    type: code
    hostname: crc
    path: /root
  difficulty: basic
  timelimit: 300
checksum: "15305765753193091144"
